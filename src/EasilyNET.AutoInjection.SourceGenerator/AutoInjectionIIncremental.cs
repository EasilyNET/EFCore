using EasilyNET.SourceGenerator.Share;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System.Collections.Immutable;
using System.Diagnostics;

namespace EasilyNET.AutoInjection.SourceGenerator;

//https://github.com/dotnet/roslyn/blob/main/docs/features/incremental-generators.md
/// <summary>
/// 自动注入生成器
/// </summary>
[Generator(LanguageNames.CSharp)]
public sealed class AutoInjectionIIncremental : IIncrementalGenerator
{
    /// <summary>
    /// 默认名字
    /// </summary>
    private const string DefaultName = "Injection";

    /// <summary>
    /// 名字前缀
    /// </summary>
    private const string Prefix = "Auto";

    private const string TransientDependencyName = "EasilyNET.AutoDependencyInjection.Core.Abstractions.ITransientDependency";
    private const string ScopedDependencyName = "EasilyNET.AutoDependencyInjection.Core.Abstractions.IScopedDependency";
    private const string SingletonDependencyName = "EasilyNET.AutoDependencyInjection.Core.Abstractions.ISingletonDependency";
    private const string DependencyInjectionAttributeName = "EasilyNET.AutoDependencyInjection.Core.Attributes.DependencyInjectionAttribute";
    private const string IgnoreDependencyAttributeName = "EasilyNET.AutoDependencyInjection.Core.Attributes.IgnoreDependencyAttribute";

    private const string DisposableName = "System.IDisposable";

    /// <summary>
    /// 过滤
    /// </summary>
    private static readonly HashSet<string> _ignoredInterfaces = new(StringComparer.Ordinal)
    {
        TransientDependencyName,
        ScopedDependencyName,
        SingletonDependencyName
    };

    /// <summary>
    /// </summary>
    /// <param name="context"></param>
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var pipeline = context.SyntaxProvider.CreateSyntaxProvider(SyntacticPredicate, SemanticTransform).Where(static context => context is not null).Collect();
        //得到命名空间
        var assemblyName = context.CompilationProvider.Select(static (c, _) => c.AssemblyName);

        //得到.csproj下配置名字
        //< PropertyGroup >
        //< InjectionName > Injection </ InjectionName >
        //</ PropertyGroup >
        //<ItemGroup >
        //<CompilerVisibleProperty Include = "InjectionName" />
        //</ItemGroup >
        var methodName = context.AnalyzerConfigOptionsProvider.Select(static (c, _) =>
        {
            c.GlobalOptions.TryGetValue("build_property.InjectionName", out var methodName);
            return methodName;
        });
        var options = assemblyName.Combine(methodName);
        var generation = pipeline.Combine(options);
        context.RegisterSourceOutput(generation, ExecuteGeneration!);
    }

    ///// <summary>
    ///// 执行生成 
    ///// </summary>
    ///// <param name="sourceContext">上下文</param>
    ///// <param name="source">
    ///// ValueTuple<ImmutableArray<ClassMetadata>, ValueTuple<string, string>>
    ///// Item1=>ImmutableArray<ClassMetadata>;
    ///// Item2.Item1=>RootNamespace
    ///// Item2.Item2=>MethodName
    /////</param>

    /// <summary>
    /// 执行生成
    /// </summary>
    /// <param name="sourceContext"></param>
    /// <param name="source"></param>
    private static void ExecuteGeneration(SourceProductionContext sourceContext, (ImmutableArray<ClassMetadata> ClassMetadatas, (string? RootNamespace, string? MethodName) Options) source)
    {
        if (!source.ClassMetadatas.Any())
        {
            return;
        }
        //方法名
        var methodName = source.Options.MethodName;
        //如果空值，就使用默认名
        if (string.IsNullOrWhiteSpace(methodName))
        {
            methodName = DefaultName;
        }
        CodeGenerationContext codeContext = new();
        codeContext.WriteLines("//该文件由源代码生成器的或别的手段生成产生的代码");
        codeContext.WriteLines("//<auto-generated/>");
        codeContext.WriteLines("#nullable enable");
        codeContext.WriteLines("using EasilyNET.AutoDependencyInjection.Core;");
        codeContext.WriteLines("using EasilyNET.AutoDependencyInjection.Core.Abstractions;");
        codeContext.WriteLines("using System;");
        codeContext.WriteLines("using Microsoft.Extensions.DependencyInjection;");
        codeContext.WriteLines($"namespace {source.Options.RootNamespace};");
        codeContext.WriteLines("[global::System.Runtime.CompilerServices.CompilerGeneratedAttribute]");
        codeContext.WriteLines($"public static partial class _{Prefix}{methodName}");
        const string add = "Add";
        using (codeContext.CodeBlock())
        {
            codeContext.WriteLines(" /// <summary>");
            codeContext.WriteLines(" /// 自动注入");
            codeContext.WriteLines(" /// </summary>");
            codeContext.WriteLines(" /// <param name=\"services\">服务集合</param>");
            codeContext.WriteLines(" /// <returns></returns>");
            codeContext.WriteLines("[global::System.Runtime.CompilerServices.CompilerGeneratedAttribute]");
            codeContext.WriteLines($"public static global::Microsoft.Extensions.DependencyInjection.IServiceCollection {add}{Prefix}{methodName}(this global::Microsoft.Extensions.DependencyInjection.IServiceCollection services)");
            using (codeContext.CodeBlock())
            {
                foreach (var temp in source.ClassMetadatas)
                {
                    foreach (var serviceType in temp.ServiceTypes)
                    {
                        codeContext.WriteLines($"services.Add(new global::Microsoft.Extensions.DependencyInjection.ServiceDescriptor(typeof({GetTypeName(serviceType)}), typeof({GetTypeName(temp.ImplementationType)}),global::Microsoft.Extensions.DependencyInjection.ServiceLifetime.{temp.Lifetime}));");
                    }
                }
                codeContext.WriteLines("return services;");
            }
        }
        Debug.WriteLine(codeContext.SourceCode);
        sourceContext.AddSource($"{Prefix}{methodName}.g.cs", codeContext.SourceText);
    }

    /// <summary>
    /// 句法谓语
    /// </summary>
    /// <param name="syntaxNode"></param>
    /// <param name="cancellationToken"></param>
    /// <returns></returns>
    private static bool SyntacticPredicate(SyntaxNode syntaxNode, CancellationToken cancellationToken)
    {
        return syntaxNode is ClassDeclarationSyntax classDeclaration &&
               //把静态与抽像过滤掉
               !classDeclaration.Modifiers.Any(m => m.IsKind(SyntaxKind.StaticKeyword) || m.IsKind(SyntaxKind.AbstractKeyword)) &&
               //公开类，或者是有添加上特性
               (classDeclaration.Modifiers.Any(m => m.IsKind(SyntaxKind.PublicKeyword)) || classDeclaration.AttributeLists.Count > 0);
    }

    /// <summary>
    /// 语义转换
    /// </summary>
    /// <param name="context">上下文</param>
    /// <param name="_"></param>
    /// <returns></returns>
    private static ClassMetadata? SemanticTransform(GeneratorSyntaxContext context, CancellationToken _)
    {
        var typeSymbol = (ITypeSymbol)context.SemanticModel.GetDeclaredSymbol(context.Node)!; //定义成
        return HasIgnoreDependencyAttribute(typeSymbol) ? default : CreateAttributeMetadata(typeSymbol) ?? CreateClassMetadata(typeSymbol);
    }

    /// <summary>
    /// 创建元数据
    /// </summary>
    /// <param name="typeSymbol"></param>
    /// <returns></returns>
    private static ClassMetadata? CreateClassMetadata(ITypeSymbol typeSymbol)
    {
        //如果没有继承那三个系统自带的生命周期接口中，其中一个
        var dependencyInterface = typeSymbol.AllInterfaces.FirstOrDefault(o => _ignoredInterfaces.Contains(o.ToDisplayString()));
        if (dependencyInterface is null)
        {
            return default;
        }

        //List<INamedTypeSymbol> interfaceNamedTypeSymbols = new();
        //foreach (var @interface in typeSymbol.AllInterfaces)
        //{
        //    //判断是否存在<IgnoreDependencyAttribute>特性,与是否忽略的接口，还有<Disposable>都过滤
        //    if (!IsIgnoreDependencyAttribute(@interface) &&
        //        !_ignoredInterfaces.Contains(@interface.ToDisplayString()) && @interface.ToDisplayString() != DisposableName)
        //    {
        //        interfaceNamedTypeSymbols.Add(@interface);
        //    }
        //}
        var allInterfaces = GetAllInterfaceNamedTypeSymbols(typeSymbol);
        return new ClassMetadata(typeSymbol, GetLifetime(dependencyInterface.ToDisplayString()))
            //如果当前类没有接口，就添加当前类
            .AddServiceTypes(allInterfaces.Any() ? allInterfaces : new[] { typeSymbol });
    }

    /// <summary>
    /// 获取所有命名为类型符号的接口
    /// </summary>
    /// <returns></returns>
    private static ImmutableArray<INamedTypeSymbol> GetAllInterfaceNamedTypeSymbols(ITypeSymbol typeSymbol)
    {
        //判断是否存在<IgnoreDependencyAttribute>特性,与是否忽略的接口，还有<Disposable>都过滤
        return typeSymbol.AllInterfaces.Where(@interface => !HasIgnoreDependencyAttribute(@interface) &&
                                                            !_ignoredInterfaces.Contains(@interface.ToDisplayString()) &&
                                                            @interface.ToDisplayString() != DisposableName).ToImmutableArray();
    }

    /// <summary>
    /// 判断是否忽略依赖注入特性
    /// </summary>
    /// <returns></returns>
    private static bool HasIgnoreDependencyAttribute(ISymbol namedTypeSymbol)
    {
        return namedTypeSymbol.GetAttributes().Any(attr => attr.AttributeClass?.ToDisplayString() == IgnoreDependencyAttributeName);
    }

    /// <summary>
    /// 创建特性
    /// </summary>
    /// <param name="typeSymbol"></param>
    /// <returns></returns>
    private static ClassMetadata? CreateAttributeMetadata(ITypeSymbol typeSymbol)
    {
        if (HasIgnoreDependencyAttribute(typeSymbol))
        {
            return default;
        }
        var attr = typeSymbol.GetAttributes().FirstOrDefault(o => o.AttributeClass?.ToDisplayString() == DependencyInjectionAttributeName);
        if (attr is null)
        {
            return default;
        }
        var lifetime = (int)attr.ConstructorArguments[0].Value!;

        //是否要添加自己
        var addSelf = attr.ConstructorArguments.ElementAtOrDefault(1).Value;
        var classMetadata = new ClassMetadata(typeSymbol, GetLifetime(lifetime));

        //todo
        classMetadata.AddServiceTypes(bool.TryParse(addSelf?.ToString(), out var addSelfResult) && addSelfResult
                                          ? new[] { typeSymbol }
                                          : GetAllInterfaceNamedTypeSymbols(typeSymbol).Any()
                                              ? GetAllInterfaceNamedTypeSymbols(typeSymbol)
                                              : new[] { typeSymbol });
        return classMetadata;
    }

    /// <summary>
    /// 得到生命周期
    /// </summary>
    /// <param name="value"></param>
    /// <returns></returns>
    /// <exception cref="NotImplementedException"></exception>
    private static string GetLifetime(string value) =>
        value switch
        {
            SingletonDependencyName => "Singleton",
            ScopedDependencyName    => "Scoped",
            TransientDependencyName => "Transient",
            _                       => throw new NotImplementedException()
        };

    /// <summary>
    /// 得到生命周期
    /// </summary>
    /// <param name="value"></param>
    /// <returns></returns>
    /// <exception cref="NotImplementedException"></exception>
    private static string GetLifetime(int value) =>
        value switch
        {
            0 => "Singleton",
            1 => "Scoped",
            2 => "Transient",
            _ => throw new NotImplementedException()
        };

    /// <summary>
    /// 得到类型名
    /// </summary>
    /// <param name="typeSymbol"></param>
    /// <returns></returns>
    private static string GetTypeName(ISymbol typeSymbol)
    {
        if (typeSymbol is not INamedTypeSymbol { IsGenericType: true } namedTypeSymbol) return typeSymbol.ToDisplayString();
        var name = typeSymbol.Name;
        var typeParameters = namedTypeSymbol.TypeParameters;
        return $"{name}<{new string(',', typeParameters.Length - 1)}>";
    }
}
