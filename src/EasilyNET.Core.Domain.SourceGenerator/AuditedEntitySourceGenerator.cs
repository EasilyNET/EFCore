using EasilyNET.SourceGenerator.Share;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System.Text.RegularExpressions;

namespace EasilyNET.Core.Domain.SourceGenerator;

/// <summary>
/// 审计后实休源代码生成器
/// </summary>
[Generator(LanguageNames.CSharp)]
public sealed class AuditedEntitySourceGenerator : ISourceGenerator
{
    private const string IMayHaveCreatorName = "EasilyNET.Core.Domains.IMayHaveCreator";
    private const string IIHasCreateTimeName = "EasilyNET.Core.Domains.IHasCreationTime";
    private const string IHasDeleterId = "EasilyNET.Core.Domains.IHasDeleterId";
    private const string IHasDeletionTime = "EasilyNET.Core.Domains.IHasDeletionTime";
    private const string IHasModificationTime = "EasilyNET.Core.Domains.IHasModificationTime";
    private const string IHasModifierId = "EasilyNET.Core.Domains.IHasModifierId";

    /// <summary>
    /// 过滤
    /// </summary>
    private readonly HashSet<string> _filter = new(StringComparer.Ordinal)
    {
        IMayHaveCreatorName,
        IIHasCreateTimeName,
        IHasDeleterId,
        IHasDeletionTime,
        IHasModificationTime,
        IHasModifierId
    };

    /// <inheritdoc />
    public void Initialize(GeneratorInitializationContext context)
    {
        //if (!Debugger.IsAttached)
        //{
        //    Debugger.Launch();
        //}
    }

    /// <inheritdoc />
    public void Execute(GeneratorExecutionContext context)
    {
        var compilation = context.Compilation;
        foreach (var syntaxTree in compilation.SyntaxTrees)
        {
            var root = syntaxTree.GetRoot();
            var semanticModel = context.Compilation.GetSemanticModel(syntaxTree);
            var classDeclarations = root.DescendantNodes().OfType<ClassDeclarationSyntax>();
            foreach (var classDeclaration in classDeclarations)
            {
                //判断是否分部类
                if (!classDeclaration.Modifiers.Any(SyntaxKind.PartialKeyword))
                {
                    continue;
                }
                // // 处理分部类并继承自 Entity`1 的情况
                // if (classDeclaration.BaseList?.Types.OfType<SimpleBaseTypeSyntax>()
                //                     .Any(typeSyntax =>
                //                     {
                //                         if (typeSyntax.Type.Kind() == SyntaxKind.GenericName)
                //                         {
                //                             var genericName = (GenericNameSyntax)typeSyntax.Type;
                //                             return genericName.Identifier.ValueText == "Entity";
                //                         }
                //                         return false;
                //                     }) ==
                //     false)
                // {
                //     continue;
                // }
                var classSymbol = semanticModel.GetDeclaredSymbol(classDeclaration);
                if (classSymbol is null)
                {
                    continue;
                }
                //只处理这接口
                foreach (var interfaceSymbol in classSymbol.AllInterfaces.Where(i => _filter.Contains(i.IsGenericType ? RemoveAngleBrackets(i.ToDisplayString()) : i.ToDisplayString())))
                {
                    //得到接口属性
                    var propertySymbols = interfaceSymbol.GetMembers().OfType<IPropertySymbol>();
                    foreach (var propertySymbol in propertySymbols)
                    {
                        var ns = classSymbol.ContainingNamespace.ToString();
                        var propertyName = propertySymbol.Name;
                        var propertyType = propertySymbol.Type.ToDisplayString();
                        //var get = propertySymbol.GetMethod;
                        //var set = propertySymbol.SetMethod;
                        CodeGenerationContext codeContext = new();
                        var getName = "get;";
                        var setName = "set;";
                        codeContext.WriteLines("// <auto-generated/>");
                        codeContext.WriteLines("using EasilyNET.Core.Domains;");
                        codeContext.WriteLines("using System;");
                        codeContext.WriteLines("using System.ComponentModel;");
                        codeContext.WriteLines($"namespace {ns};");
                        codeContext.WriteLines($"public partial class {classSymbol.Name}");
                        using (codeContext.CodeBlock())
                        {
                            codeContext.WriteLines($"public virtual {propertyType} {propertyName} {{{getName} {setName}}}");
                        }
                        context.AddSource($"{interfaceSymbol.Name}.{classSymbol.Name}.g.cs", codeContext.SourceText);
                        // Debug.WriteLine($"Property Name: {propertyName}, Property Type: {propertyType}, Accessibility: {propertyAccessibility}");
                        // Debug.WriteLine(source);
                    }
                }
            }
        }
    }

    /// <summary>
    /// 使用正则表达式去掉尖括号
    /// </summary>
    /// <param name="input"></param>
    /// <returns></returns>
    private static string RemoveAngleBrackets(string input)
    {
        // 使用正则表达式去掉尖括号
        const string pattern = "<[^>]*>";
        var result = Regex.Replace(input, pattern, "");
        return result;
    }
}